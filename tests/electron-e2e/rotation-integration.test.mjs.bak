/**
 * rotation-integration.test.mjs
 * 
 * Tests key rotation lifecycle integration
 * 
 * Validates:
 * - Rotation completion triggers scheduler update
 * - nextRun timestamp resets
 * - Status-change event fires
 * - UI reflects rotation completion
 */

import { navigate, waitForSelector, clickElement, waitForText, getElementText } from './helpers/waitForSelector.js';
import { triggerRotation, waitForIpcEvent, ipcInvoke } from './helpers/ipc.js';

/**
 * Test: Key rotation triggers scheduler update
 * 
 * @param {Object} context - { electronProcess, cdpClient, close }
 */
export default async function test({ cdpClient }) {
  console.log('[Test] Navigating to settings page...');

  // Step 1: Navigate to /settings/sync
  await navigate(cdpClient, 'http://localhost:3000/settings/sync');
  await waitForSelector(cdpClient, 'main', { timeout: 10000 });
  console.log('[Test] Settings page loaded');

  // Step 2: Click "Scheduler" tab
  console.log('[Test] Clicking Scheduler tab...');
  await clickElement(cdpClient, 'button:has-text("Scheduler")');
  await waitForSelector(cdpClient, '.status-card, [data-testid="status-card"]', { timeout: 5000 });
  console.log('[Test] Scheduler tab active');

  // Step 3: Get initial nextRun timestamp
  console.log('[Test] Getting initial nextRun...');
  const nextRunBefore = await ipcInvoke(cdpClient, 'sync:scheduler:getNextRun', null);
  
  if (nextRunBefore === null) {
    console.warn('[Test] nextRun is null (scheduler may not be initialized)');
  } else {
    console.log(`[Test] nextRun before rotation: ${new Date(nextRunBefore).toISOString()}`);
  }

  // Step 4: Capture initial badge state
  const badgeSelector = 'nav a[href="/settings/sync"] span';
  const badgeTextBefore = await getElementText(cdpClient, badgeSelector);
  console.log(`[Test] Badge state before rotation: "${badgeTextBefore}"`);

  // Step 5: Trigger rotation completion (via test API)
  console.log('[Test] Triggering key rotation completion...');
  await triggerRotation(cdpClient);
  console.log('[Test] Rotation triggered');

  // Step 6: Wait for status-change event
  console.log('[Test] Waiting for sync:status-change event...');
  const eventData = await waitForIpcEvent(cdpClient, 'sync:status-change', { timeout: 15000 });
  console.log('[Test] ✅ Received status-change event');
  console.log('[Test] Event data:', JSON.stringify(eventData, null, 2));

  // Step 7: Verify nextRun updated
  console.log('[Test] Checking if nextRun updated...');
  const nextRunAfter = await ipcInvoke(cdpClient, 'sync:scheduler:getNextRun', null);
  
  if (nextRunAfter === null) {
    console.warn('[Test] nextRun is null after rotation');
  } else {
    console.log(`[Test] nextRun after rotation: ${new Date(nextRunAfter).toISOString()}`);
    
    // nextRun should be in the future (within ~6h)
    const timeUntilNext = nextRunAfter - Date.now();
    if (timeUntilNext < 0) {
      throw new Error('nextRun is in the past after rotation');
    }
    
    if (timeUntilNext > 6 * 60 * 60 * 1000 + 5000) {
      console.warn(`nextRun is very far in future: ${Math.round(timeUntilNext / 3600000)}h`);
    } else {
      console.log(`[Test] ✅ nextRun is valid: ${Math.round(timeUntilNext / 1000)}s from now`);
    }

    // nextRun should be different from before (if it was set)
    if (nextRunBefore && nextRunAfter === nextRunBefore) {
      console.warn('[Test] nextRun did not change after rotation');
    } else if (nextRunBefore) {
      console.log('[Test] ✅ nextRun timestamp updated');
    }
  }

  // Step 8: Verify UI reflects rotation completion
  console.log('[Test] Checking UI for rotation completion indicator...');
  
  // May show "Last check: just now" or similar
  const hasRecentCheck = await waitForText(
    cdpClient,
    'main',
    /just now|few seconds|moments ago|Last (check|run|sync)/i,
    { timeout: 5000 }
  ).then(() => true).catch(() => false);

  if (!hasRecentCheck) {
    console.warn('[Test] Recent check indicator not found');
  } else {
    console.log('[Test] ✅ Recent check indicator displayed');
  }

  // Step 9: Verify badge updated
  console.log('[Test] Checking if badge updated...');
  const badgeTextAfter = await getElementText(cdpClient, badgeSelector);
  console.log(`[Test] Badge state after rotation: "${badgeTextAfter}"`);

  if (badgeTextAfter === badgeTextBefore) {
    console.warn('[Test] Badge did not change after rotation (may already be up-to-date)');
  } else {
    console.log('[Test] ✅ Badge updated');
  }

  // Expected badge: ✓ (up-to-date) or ! (needs-sync) or ↻ (syncing)
  const validBadges = ['✓', '!', '↻'];
  if (!validBadges.includes(badgeTextAfter)) {
    console.warn(`[Test] Badge "${badgeTextAfter}" not in expected states: ${validBadges.join(', ')}`);
  } else {
    console.log(`[Test] ✅ Badge is valid: "${badgeTextAfter}"`);
  }

  // Step 10: Verify health report updated (if event data available)
  if (eventData) {
    console.log('[Test] Validating health report...');
    
    if (eventData.needsSync === undefined) {
      console.warn('[Test] Health report missing needsSync field');
    } else {
      console.log(`[Test] ✅ needsSync: ${eventData.needsSync}`);
    }

    if (eventData.lastCheck === undefined) {
      console.warn('[Test] Health report missing lastCheck field');
    } else {
      const lastCheckAge = Date.now() - eventData.lastCheck;
      if (lastCheckAge > 5000) {
        console.warn(`[Test] lastCheck is ${Math.round(lastCheckAge / 1000)}s old (expected recent)`);
      } else {
        console.log(`[Test] ✅ lastCheck is recent (${Math.round(lastCheckAge / 1000)}s ago)`);
      }
    }

    if (eventData.warnings && eventData.warnings.length > 0) {
      console.log(`[Test] Health report has ${eventData.warnings.length} warning(s)`);
    }
  }

  // Step 11: Verify scheduler is still active
  console.log('[Test] Verifying scheduler is still active...');
  const finalNextRun = await ipcInvoke(cdpClient, 'sync:scheduler:getNextRun', null);
  
  if (finalNextRun === null) {
    throw new Error('Scheduler stopped after rotation (should remain active)');
  }
  console.log('[Test] ✅ Scheduler is active');

  console.log('[Test] ✅ All rotation integration tests passed');
}
